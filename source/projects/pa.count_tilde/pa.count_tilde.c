/*
// Copyright (c) 2016 Eliott Paris.
// For information on usage and redistribution, and for a DISCLAIMER OF ALL
// WARRANTIES, see the file, "LICENSE.txt," in this distribution.
*/

//! @brief Outputs a signal increasing by 1 for each sample elapsed

#include <m_pd.h>

static t_class *pa_count_tilde_class;

typedef struct _pa_count_tilde
{
    t_object    m_obj;
    
    long       m_min;
    long       m_max;
    long       m_value;
    
    t_inlet*    m_in1;
    t_outlet*   m_out;
    
} t_pa_count_tilde;

static void pa_count_tilde_setminmax(t_pa_count_tilde* x, int min, int max)
{
    if(min > max) min = max;
    if(max < min) max = min;
    
    x->m_min = min;
    x->m_max = max;
}

static void pa_count_tilde_float(t_pa_count_tilde* x, float f)
{
    pa_count_tilde_setminmax(x, (int)f, x->m_max);
}

static void pa_count_tilde_ft1(t_pa_count_tilde* x, float f)
{
    pa_count_tilde_setminmax(x, x->m_min, (int)f);
}

static t_int *pa_count_tilde_perform(t_int *w)
{
    t_pa_count_tilde *x = (t_pa_count_tilde *)(w[1]);
    t_sample  *out = (t_sample *)(w[2]);
    int vecsize = (int)(w[3]);
    
    // cache our value
    int value = x->m_value;
    
    while(vecsize--)
    {
        if(value > x->m_max)
        {
            value = x->m_min;
        }
        
        // set the output sample value then increment output pointer
        *out++ = value;
        
        // increment the value
        ++value;
    }
    
    x->m_value = value;

    return (w+4);
}

static void pa_count_tilde_dsp(t_pa_count_tilde* x, t_signal **sp)
{
    dsp_add(pa_count_tilde_perform, 3,
            x,
            sp[0]->s_vec,
            sp[0]->s_n);
}

static void *pa_count_tilde_new(t_symbol *s, int argc, t_atom *argv)
{
    t_pa_count_tilde *x = (t_pa_count_tilde*)pd_new(pa_count_tilde_class);
    if(x)
    {
        x->m_min = 0;
        x->m_max = 44100;
        x->m_value = 0;
        
        // first argument set the minimum count value
        if(argc >= 1 && argv[0].a_type == A_FLOAT)
        {
            x->m_min = argv[0].a_w.w_float;
        }
        
        // second argument set the maximum count value
        if(argc >= 2 && argv[1].a_type == A_FLOAT)
        {
            x->m_max = argv[1].a_w.w_float;
        }
        
        // create inlet to set maximum count value (first inlet is generated by pd)
        x->m_in1 = inlet_new((t_object*)x, &x->m_obj.ob_pd, gensym("float"), gensym("ft1"));
        x->m_out = outlet_new((t_object*)x, &s_signal);
    }
    
    return (x);
}

static void pa_count_tilde_free(t_pa_count_tilde *x)
{
    // free dynamically allocated IO
    inlet_free(x->m_in1);
    outlet_free(x->m_out);
}

extern void setup_pa0x2ecount_tilde(void)
{
    t_class* c = class_new(gensym("pa.count~"),
                           (t_newmethod)pa_count_tilde_new, (t_method)pa_count_tilde_free,
                           sizeof(t_pa_count_tilde), CLASS_DEFAULT, A_GIMME, 0);
    if(c)
    {
        class_addmethod(c, (t_method)pa_count_tilde_dsp, gensym("dsp"), A_CANT);
        class_addmethod(c, (t_method)pa_count_tilde_float, gensym("float"), A_FLOAT, 0);
        class_addmethod(c, (t_method)pa_count_tilde_ft1, gensym("ft1"), A_FLOAT, 0);
    }
    
    pa_count_tilde_class = c;
}
